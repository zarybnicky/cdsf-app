/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/athletes/{idt}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Id of the particular person. */
                    idt: components["schemas"]["Id.Person"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            entity?: components["schemas"]["Athlete"];
                        };
                    };
                };
                401: components["responses"]["UnauthorizedError"];
                500: components["responses"]["ServerFailure"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/athletes/current": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            /** @description The array can be empty. */
                            collection: components["schemas"]["Athlete"][];
                            paging?: components["schemas"]["Paging"] & unknown;
                        };
                    };
                };
                401: components["responses"]["UnauthorizedError"];
                500: components["responses"]["ServerFailure"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/athletes/current/competitions/registrations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: {
            parameters: {
                query?: {
                    page?: components["schemas"]["Page"];
                    /** @description If pageSize is empty server decides about number of items to return. */
                    pageSize?: components["schemas"]["PageSize"];
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            /** @description The array can be empty. */
                            collection: components["schemas"]["EventRegistration"][];
                            paging?: components["schemas"]["Paging"];
                        };
                    };
                };
                401: components["responses"]["UnauthorizedError"];
                500: components["responses"]["ServerFailure"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/athletes/current/competitions/results": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: {
            parameters: {
                query?: {
                    page?: components["schemas"]["Page"];
                    /** @description If pageSize is empty server decides about number of items to return. */
                    pageSize?: components["schemas"]["PageSize"];
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            /** @description The array can be empty. */
                            collection: components["schemas"]["EventRegistration"][];
                            paging?: components["schemas"]["Paging"];
                        };
                    };
                };
                401: components["responses"]["UnauthorizedError"];
                500: components["responses"]["ServerFailure"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/athletes/{idt}/competitions/{competitionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Id of the particular person. */
                    idt: components["schemas"]["Id.Person"];
                    /** @description Id of the particular competition to be removed from. */
                    competitionId: components["schemas"]["Id.Competition"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description id is missing, or is malformed (not an integer) */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                401: components["responses"]["UnauthorizedError"];
                /** @description entity of the id is not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                500: components["responses"]["ServerFailure"];
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/competitions/{competitionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns data of single competition.
         * @description Loads detailed data for the competition.
         *
         *     Anonymous clients:
         *
         *     * Only competitions within range of -10 to +20 days (including) are available.
         *     * Rate limiting is applied. Rate limit is shared between all API endpoints.
         *
         *     Authorized clients:
         *
         *     * Rate limiting is loose or none.
         *
         */
        get: operations["loadCompetition"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/competitions/{competitionId}/startlist": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns competitors of single competition.
         * @description List of all competitors (both registered and excudes) for the selected competition.
         *
         *     Anonymous clients:
         *
         *     * Only competitions within range of -10 to +20 days (including) are available.
         *     * Rate limiting is applied. Rate limit is shared between all API endpoints.
         *
         *     Authorized clients:
         *
         *     * rate limiting is loose or none.
         *
         */
        get: operations["listCompetitionCompetitors"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/competitions/{competitionId}/result": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns result for the competition.
         * @description Overall result for the competition is returned, including ranking, and marks.
         *
         *     Anonymous clients:
         *
         *     * Only competitions within range of -10 to +20 days (including) are available.
         *     * Rate limiting is applied. Rate limit is shared between all API endpoints.
         *
         *     Authorized clients:
         *
         *     * rate limiting is loose or none.
         *
         */
        get: operations["loadCompetitionResult"];
        /**
         * Stores/updates result for competition.
         * @description Storing or updating competition result. If result does not exist, it is created, otherwise it is replaced (not merged).
         *
         *     Storing result is allowed only for limited time after the competition ends, typically a day or two after event ends.
         *
         */
        put: operations["storeCompetitionResult"];
        post?: never;
        /** Deletes result for competition. */
        delete: operations["deleteCompetitionResult"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/competitions/{competitionId}/dances": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns dances for the competition.
         * @deprecated
         * @description Overall dances for the competition is returned.
         *
         *     Anonymous clients:
         *
         *     * Only competitions within range of -10 to +20 days (including) are available.
         *     * Rate limiting is applied. Rate limit is shared between all API endpoints.
         *
         *     Authorized clients:
         *
         *     * rate limiting is loose or none.
         *
         */
        get: operations["loadCompetitionDances"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/competitors/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Id of the particular person. */
                    id: components["schemas"]["Id.Competitor"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            entity?: components["schemas"]["Competitor"];
                        };
                    };
                };
                401: components["responses"]["UnauthorizedError"];
                500: components["responses"]["ServerFailure"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/credentials": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["Credentials"];
                };
            };
            responses: {
                /** @description OK */
                201: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["BearerToken"];
                    };
                };
                /** @description Request body is malformed or any of login or password is empty. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Credentials are invalid. */
                401: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                500: components["responses"]["ServerFailure"];
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/credentials/current": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete: {
            parameters: {
                query: {
                    purpose: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Request parameter is malformed or missing. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                500: components["responses"]["ServerFailure"];
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/competition_events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Lists events within selected date range.
         * @description A list of basic info of competition events. Date range can be filtered using parameters 'from' and 'to'. If parameters are omitted, default date range is used.
         *
         *     Anonymous clients:
         *
         *     * Default date range is -10 to +20 days (including), with no posibility to select any range for extending the range.
         *     * Rate limiting is applied. Rate limit is shared between all API endpoints.
         *
         *     Authorized clients:
         *
         *     * Default date range is -10 to +20 days (including), with posibility to select any range with maximal duration of half a year.
         *     * rate limiting is loose or none.
         *
         */
        get: operations["listEvents"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/competition_events/{eventId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Delivers the competition event of the requested id.
         * @description Loads complete information for requested event, including officials and competitions. Start lists are not included, only count of registered and excused competitors is given.
         *
         *     Anonymous clients:
         *
         *     * Only events within range of -10 to +20 days (including) are available.
         *     * Rate limiting is applied. Rate limit is shared between all API endpoints.
         *
         *     Authorized clients:
         *
         *     * Rate limiting is loose or none.
         *
         */
        get: operations["loadEvent"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/competition_events/{eventId}/startlist": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns all competitors of the event.
         * @description List of all competitors (both registered and excused) of selected event, including linkage to competitions. If a competitor competes in more competitions, it is listed more times, separately for each competition.
         *
         *     Anonymous clients:
         *
         *     * Only events within range of -10 to +20 days (including) are available.
         *     * Rate limiting is applied. Rate limit is shared between all API endpoints.
         *
         *     Authorized clients:
         *
         *     * Rate limiting is loose or none.
         *
         */
        get: operations["listEventCompetitors"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/notifications": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: {
            parameters: {
                query?: {
                    page?: components["schemas"]["Page"];
                    /** @description If pageSize is empty server decides about number of items to return. */
                    pageSize?: components["schemas"]["PageSize"];
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK
                 *     Returned collection always contains all notifications of the earliest day present in the collection.
                 *      */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            /** @description The array can be empty. */
                            collection: components["schemas"]["Notification"][];
                            paging?: components["schemas"]["Paging"];
                        };
                    };
                };
                401: components["responses"]["UnauthorizedError"];
                500: components["responses"]["ServerFailure"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/notifications/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    id: components["schemas"]["Id.Notification"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            entity?: components["schemas"]["Notification"];
                        };
                    };
                };
                /** @description id is missing, or is malformed (not an integer) */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                401: components["responses"]["UnauthorizedError"];
                /** @description entity of the id is not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                500: components["responses"]["ServerFailure"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/officials": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns list of officials with licenses valid to current date.
         * @description Detailed information about officials available to current date, including their classes and licences.
         *
         */
        get: operations["listOfficials"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/officials/{officialId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns official details.
         * @description Detailed information about official available to current date, including its classes and licences.
         *
         */
        get: operations["loadOfficial"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * @description Under 8 = Do 8 let
         *     Juvenile I = Děti I
         *     Juvenile II = Děti II
         *     Junior I = Junioři I
         *     Junior II = Junioři II
         *     Youth = Mládež
         *     Adult = Dospělí
         *     Under 21 = Do 21 let
         *     Senior I = Senioři I
         *     Senior II = Senioři II
         *     Senior III = Senioři III
         *     Senior IV = Senioři IV
         *     Senior V = Senioři V
         *
         * @example Adult
         * @enum {string}
         */
        Age: "Under 8" | "Juvenile I" | "Juvenile II" | "Juvenile" | "Junior I" | "Junior II" | "Junior" | "Youth" | "Adult" | "Under 21" | "Senior" | "Senior I" | "Senior II" | "Senior III" | "Senior IV" | "Senior V";
        Athlete: {
            /** @description Formatted by server */
            name: string;
            validFor?: components["schemas"]["Date"] & unknown;
            idt: number;
            age: components["schemas"]["Age"];
            /**
             * Format: #/components/schemas/Date
             * @description Last day of medical checkup validity, minimum of all available values
             */
            medicalCheckupExpiration?: string;
            rankingPoints?: components["schemas"]["AthleteRankingPoints"][];
            stt?: components["schemas"]["AthleteRankingPoints"] & unknown;
            lat?: components["schemas"]["AthleteRankingPoints"] & unknown;
            ten?: components["schemas"]["AthleteRankingPoints"] & unknown;
            /** Format: URI */
            avatar?: string;
            /** Format: URI */
            barcode?: string;
        };
        AthleteRankingPoints: WithRequired<components["schemas"]["CompetitorRankingPoints"], "id" | "series" | "discipline" | "rankingPointsAge" | "competitors"> & {
            /** @description Formatted name */
            partner?: string;
            idt?: number;
            /** Format: URI */
            avatar?: string;
            /**
             * Format: #/components/schemas/Date
             * @description Last day of medical checkup validity
             */
            medicalCheckupExpiration?: string;
            personalClass?: components["schemas"]["RankingClass"];
            personalPoints?: number;
            personalDomesticFinaleCount?: number;
            personalForeignFinaleCount?: number;
            ranklistRanking?: number;
            ranklistPoints?: number;
        };
        BearerToken: string;
        /**
         * @description Club of the competitor. It may differ from individual partner's club.
         * @example Neznámý z Nejdedál
         */
        Club: string;
        Competition: {
            competitionId: components["schemas"]["Id.Competition"];
            date?: components["schemas"]["Date"];
            competitors: components["schemas"]["CompetitionCompetitors"];
            class?: components["schemas"]["RankingClass"];
            toClass?: components["schemas"]["RankingClass"];
            discipline: components["schemas"]["Discipline"];
            age: components["schemas"]["Age"];
            grade: components["schemas"]["CompetitionGrade"];
            series?: components["schemas"]["CompetitionSeries"];
            chairPersonId: components["schemas"]["Id.Official"];
            dances?: components["schemas"]["Dance"][];
            danceDisciplines?: components["schemas"]["DanceDiscipline"][];
            /** Format: #/components/schemas/DateTime */
            registrationEnd?: string;
            /**
             * @description Starting fee per competitor, e.g. for a whole couple or formation.
             * @example 250
             */
            registrationFee?: number;
            /**
             * @description Count of registered, not excused, competitors.
             * @example 13
             */
            registered?: number;
            /**
             * @description Count of excused competitors.
             * @example 2
             */
            excused?: number;
        };
        /**
         * @example Ranking
         * @enum {string}
         */
        CompetitionGrade: "Cup" | "Ranking" | "League" | "Championship" | "TopLevel" | "SuperLeague" | "GCup";
        /**
         * @example DanceSport
         * @enum {string}
         */
        CompetitionSeries: "DanceForAll" | "DanceSport";
        /**
         * @example Couple
         * @enum {string}
         */
        CompetitionCompetitors: "Couple" | "SoloDancer" | "Duo" | "Group" | "ProAm" | "Team" | "Formation";
        /** @description id/Official is generally required. Only in case when the judge is added on venue, it can be ommited. */
        CompetitionOfficial: components["schemas"]["OfficialId"] & {
            type: components["schemas"]["OfficialType"];
            /**
             * @description Required only for judges results, index specifies judge position in marks array if judges are the same in all rounds.
             * @example 2
             */
            index?: number;
            /**
             * @description Only for judges, label is informational field.
             * @example AA
             */
            label?: string;
        } & components["schemas"]["Official"];
        CompetitionResult: {
            /** @enum {string} */
            type: "partial" | "preliminary" | "approved";
            competitionId: components["schemas"]["Id.Competition"];
            /**
             * Format: datetime
             * @description DateTime in format as in example, in UTC.
             * @example 2020-15-04T12:30:00
             */
            completedAt: string;
            officials: components["schemas"]["CompetitionOfficial"][];
            /** @description The array contains only competitors that were competing. No excused competitor is included. */
            competitors: components["schemas"]["CompetitorResult"][];
            rounds: components["schemas"]["DancedRound"][];
            /** @description Markdown supported. */
            invigilatorReport?: string;
        };
        CompetitionStartListCompetitor: {
            competitorId: components["schemas"]["Id.Competitor"];
            type?: components["schemas"]["CompetitionCompetitors"];
            name?: string & unknown;
            captain?: string;
            club?: components["schemas"]["Club"];
            country?: components["schemas"]["Country"];
            persons?: components["schemas"]["CompetitorPersons"];
            coupleOrDuos?: components["schemas"]["CompetitorCoupleOrDuos"];
        };
        CompetitionRegistration: {
            idt?: components["schemas"]["Id.Person"];
            compId?: components["schemas"]["Id.Competition"] & unknown;
            competitionId: components["schemas"]["Id.Competition"];
            category?: components["schemas"]["CompetitionCompetitors"] & unknown;
            competitors?: components["schemas"]["CompetitionCompetitors"];
            class: components["schemas"]["RankingClass"];
            discipline: components["schemas"]["Discipline"];
            age: components["schemas"]["Age"];
            grade?: components["schemas"]["CompetitionGrade"];
            series?: components["schemas"]["CompetitionSeries"];
            ranking?: number;
            rankingTo?: number;
            /** Format: #/components/schemas/DateTime */
            registrationEnd?: string;
        };
        CompetitorCoupleOrDuos: {
            id: components["schemas"]["Id.Competitor"];
            idt1: components["schemas"]["Id.Person"];
            name1?: string;
            surname1: string;
            sex1?: string;
            idt2: components["schemas"]["Id.Person"];
            name2?: string;
            surname2: string;
            sex2?: string;
            age?: components["schemas"]["Age"];
            backup?: boolean;
        }[];
        CompetitorPersons: {
            id: components["schemas"]["Id.Competitor"];
            idt: components["schemas"]["Id.Person"];
            name?: string;
            surname: string;
            sex?: string;
            age?: components["schemas"]["Age"];
            backup?: boolean;
        }[];
        Competitor: {
            id: components["schemas"]["Id.Competitor"];
            type: components["schemas"]["CompetitionCompetitors"];
            name?: string;
            country?: components["schemas"]["Country"];
            /** @description club or city or both */
            club?: string;
            shortLoanRequired?: boolean;
            persons?: components["schemas"]["CompetitorPersons"];
            coupleOrDuos?: components["schemas"]["CompetitorCoupleOrDuos"];
            rankingPoints?: components["schemas"]["CompetitorRankingPoints"][];
        };
        CompetitorResult: {
            competitorId: components["schemas"]["Id.Competitor"];
            club: string;
            completion?: components["schemas"]["Completion"];
            /** @example 225 */
            startNumber: number;
            /** @example 7 */
            ranking?: number;
            /** @example 8 */
            rankingTo?: number;
            rounds: {
                round: components["schemas"]["Round"];
                /** @example 7 */
                ranking: number;
                /** @example 8 */
                rankingTo?: number;
                marks: components["schemas"]["Marks"];
                /** @example 35.787 */
                sum: number;
                danceResults?: number[];
            }[];
        };
        CompetitorRankingPoints: {
            id: components["schemas"]["Id.RankingPoints"];
            competitorId: components["schemas"]["Id.Competitor"];
            age?: components["schemas"]["Age"] & unknown;
            series: components["schemas"]["CompetitionSeries"];
            discipline: components["schemas"]["Discipline"];
            rankingPointsAge: components["schemas"]["Age"];
            competitors: components["schemas"]["CompetitionCompetitors"];
            class?: components["schemas"]["RankingClass"];
            points?: number;
            domesticFinaleCount?: number;
            foreignFinaleCount?: number;
            approved?: boolean;
        };
        /** @description The object is optional, when present at least completion must be present. If lastRound or lastDance is missing, both should be derived from marks and ranking. */
        Completion: {
            /** @enum {string} */
            completion?: "Normal" | "Retirement" | "Disqualification";
            lastRound?: components["schemas"]["Round"];
            lastDance?: components["schemas"]["Dance"];
        };
        /**
         * @description Three-letter state code, according to ISO_3166-1 alpha 3
         * @example DEU
         */
        Country: string;
        Credentials: {
            login: string;
            password: string;
            purpose: string;
        };
        /**
         * @example Slowfox
         * @enum {string}
         */
        Dance: "Waltz" | "Tango" | "Viennese Waltz" | "Slowfox" | "Quickstep" | "Samba" | "Chachacha" | "Rumba" | "Paso Doble" | "Jive" | "Polka" | "Salsa";
        /**
         * @example Standard
         * @enum {string}
         */
        DanceDiscipline: "Standard" | "Latin" | "Other";
        DancedRound: {
            round: components["schemas"]["Round"];
            dances: components["schemas"]["Dance"][];
            judges?: components["schemas"]["RoundJudge"][];
        };
        /**
         * Format: date
         * @description Date in ISO format.
         * @example 2020-01-31
         */
        Date: string;
        /**
         * Format: datetime
         * @description Date in ISO format (UTC).
         * @example 2020-01-31T14:15:16Z
         */
        DateTime: string;
        /**
         * @example Latin
         * @enum {string}
         */
        Discipline: "Standard" | "Latin" | "TenDances" | "Standard+Latin" | "SingleOfTenDances" | "FreeStyle" | "Breaking" | "Other";
        Event: components["schemas"]["EventInfo"] & {
            /** @example Kasalice */
            location: string;
            /** @example CDSF */
            organizer?: string;
            /** @example ACME corp. */
            executor: string;
            officials: components["schemas"]["Official"][];
            competitions: components["schemas"]["Competition"][];
            registrationState?: components["schemas"]["RegistrationState"];
            resultsCanBeSentBefore?: components["schemas"]["DateTime"] & unknown;
        };
        EventInfo: {
            eventId: components["schemas"]["Id.Event"];
            dateFrom: components["schemas"]["Date"] & unknown;
            dateTo?: components["schemas"]["Date"];
            /** @example Horní-dolní Cup */
            eventTitle: string;
            /** @example Horní-dolní */
            location: string;
        };
        EventRegistration: {
            eventId?: components["schemas"]["Id.Event"] & unknown;
            eventName: string;
            city: string;
            address?: string;
            gps?: string;
            /** Format: #/components/schemas/Date */
            date: string;
            competitions: components["schemas"]["CompetitionRegistration"][];
        };
        EventStartListCompetitor: components["schemas"]["CompetitionStartListCompetitor"] & {
            competitionId: components["schemas"]["Id.Competition"];
            presence: components["schemas"]["Presence"];
            startsWithRound?: number;
        };
        /**
         * @description Id of a competition. See @Competition.
         * @example 45567
         */
        "Id.Competition": number;
        /**
         * @description Id of a competitor, differs from person id (idt) and ranking points id. this id is usually duplicate of partner1Id.
         *
         * @example 11258
         */
        "Id.Competitor": number;
        /**
         * @description Id of a competition event. See @EventInfo, @Event.
         * @example 42
         */
        "Id.Event": number;
        "Id.Notification": number;
        /**
         * @description Id of an official. See @Official.
         * @example 18034567
         */
        "Id.Official": number;
        /**
         * @description Id of a single person. In CDSF information system, the id is called "IDT".
         * @example 18034567
         */
        "Id.Person": number;
        /**
         * @description Id of competitor points/discipline info. See @AthleteRankingPoints, @CompetitorRankingPoints.
         * @example 45567
         */
        "Id.RankingPoints": number;
        /**
         * @description * `-|-|x|-|x|x|x|x|x|x|x|-|x|-|x|-|-|-|-|x|x|x|-|x|x` -- crosses from five judges for five dances
         *     * `3|3|4|4|5|2|3|1|1|2|1|1|1|2|5|5|5|3|3|5|6` -- marks from seven judges for three dances
         *     * `6.75|8.5|...` -- marks for AJS
         *     * crosses/marks/points ordered by judge index are first grouped by dances, then dances follow each other without separation
         *     * `1-W|1-T|1-V|1-Sf|1-Q|2-W|2-T|...|5-V|5-Sf|5-Q`
         *     * each mark can be followed with optional sequence of mark attributes separated with commad enclosed in parentheses, e.g. `x(w)|-(d)|...`
         *         * unknown attributes are rejected by the API
         *         * currently supported attributes are: 'w' = warning, 'd' = suggestion to disqualify
         *
         * @example x|-|x|-|x|x|x|-|-|x|x|-|x|-|x|-|x|x|-|x|x|x|-|x|x
         */
        Marks: string;
        Notification: {
            id: components["schemas"]["Id.Notification"];
            /** @enum {string} */
            type: "MedicalCheckupExpiration" | "CompetitionChange" | "CompetitionRegistrationEndChange" | "CompetitionMessage" | "ClubTransferCompletion" | "ExecutiveBoardMinutes" | "AdjudicatorsMessage" | "OfficialsMessage" | "DivisionRepresentativeMessage" | "ClubRepresentativeMessage";
            /** Format: #/components/schemas/DateTime */
            created: string;
            /** @description simple string, or single line (with inline tags only) markdown */
            caption: string;
            /** @description simplified markdown */
            message?: string;
            /** Format: URI */
            link?: string;
            /** Format: email */
            contact?: string;
            author?: string;
            overrideMuting?: boolean;
        };
        OfficialId: {
            id?: components["schemas"]["Id.Official"];
        };
        Official: components["schemas"]["OfficialId"] & {
            /** @example Květoslav */
            firstName: string;
            /** @example Zřídkaveselý */
            familyName: string;
            club?: string;
            country?: components["schemas"]["Country"];
            licences?: components["schemas"]["OfficialLicence"][];
        };
        OfficialLicence: {
            type: components["schemas"]["OfficialType"];
            grade: components["schemas"]["OfficialLicenceGrade"];
            discipline?: components["schemas"]["Discipline"];
        };
        /**
         * @description The highest competition class that the offical is allowed to participate on.
         *
         * @example -C
         * @enum {string}
         */
        OfficialLicenceGrade: "-E" | "-D" | "-C" | "-B" | "-A" | "-S";
        /**
         * @description * MoC = Master of Ceremony
         *     * ChP = Chairperson
         *     * Inv = Invigilator
         *     * Adj = Judge
         *     * Scr = Scrutineer
         *     * LScr = Lead Scrutineer
         *     * SInv = Syllabus invigilator
         *
         * @example Adj
         * @enum {string}
         */
        OfficialType: "MoC" | "ChP" | "Inv" | "Adj" | "LScr" | "Scr" | "SInv";
        /** @default 1 */
        Page: number;
        /** @default maxint */
        PageSize: number;
        Paging: {
            page?: number;
            pageSize?: number;
            totalCount?: number;
        };
        Presence: string & ("0" | "1" | "2" | "3" | "Excused" | "Registered" | "NoShow" | "WaitingList");
        /**
         * @description Entry = TPV
         *     S = M
         *
         * @enum {string}
         */
        RankingClass: "Entry" | "E" | "D" | "C" | "B" | "A" | "S" | "Open" | "Novice" | "Bronze" | "Silver" | "Gold";
        /**
         * @description Open allows registering competitors, Planned and Closed do not.
         * @enum {string}
         */
        RegistrationState: "Planned" | "Open" | "Closed";
        ResultUploadError: {
            field?: string[];
        };
        /**
         * @description Enum contents is arbitrary to allow naming rounds as needed. CompetitorResult.Rounds[x].Round must contain only values from this enum.
         * @enum {string}
         */
        Round: "1" | "2" | "R" | "SF" | "F" | "any round name";
        RoundJudge: components["schemas"]["OfficialId"] & {
            /**
             * @description Index specifies judge position in marks array.
             * @example 2
             */
            index: number;
            /**
             * @description Label is informational.
             * @example AA
             */
            label?: string;
        };
    };
    responses: {
        /** @description Rate limit achieved. */
        RateLimitAchieved: {
            headers: {
                /** @description Seconds to delay the following request for the resource in order to get valid response. */
                "Retry-After"?: number;
                /** @description Request limit per hour. */
                "X-RateLimit-Limit"?: number;
                [name: string]: unknown;
            };
            content?: never;
        };
        /** @description Current rate limitation state. */
        RateLimitInfo: {
            headers: {
                /** @description Request limit per hour. */
                "X-RateLimit-Limit"?: number;
                /** @description The number of requests left for the time window. */
                "X-RateLimit-Remaining"?: number;
                /** @description Remaining seconds before current rate limit is reset. */
                "X-RateLimit-Reset"?: number;
                [name: string]: unknown;
            };
            content?: never;
        };
        /** @description Unspecified server failure */
        ServerFailure: {
            headers: {
                [name: string]: unknown;
            };
            content?: never;
        };
        /** @description Access token is missing or invalid */
        UnauthorizedError: {
            headers: {
                [name: string]: unknown;
            };
            content?: never;
        };
    };
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    loadCompetition: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Id of the particular competition to be loaded. */
                competitionId: components["schemas"]["Id.Competition"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Competition found. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        entity?: components["schemas"]["Competition"];
                    };
                };
            };
            /** @description Bad input parameter, e.g. competitionId is not an integer number, or competition does not belong to allowed date range. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Required competition does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            429: components["responses"]["RateLimitAchieved"];
            500: components["responses"]["ServerFailure"];
        };
    };
    listCompetitionCompetitors: {
        parameters: {
            query?: {
                page?: components["schemas"]["Page"];
                /** @description If pageSize is empty server decides about number of items to return. */
                pageSize?: components["schemas"]["PageSize"];
            };
            header?: never;
            path: {
                /** @description Id of the competition startlist of which is requested. */
                competitionId: components["schemas"]["Id.Competition"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Competition found, all its competitors are returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The array can be empty. */
                        collection: components["schemas"]["CompetitionStartListCompetitor"][];
                        paging?: components["schemas"]["Paging"];
                    };
                };
            };
            /** @description Bad input parameter, e.g. competitionId is not an integer number, or competition does not belong to allowed date range. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Required competition does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            429: components["responses"]["RateLimitAchieved"];
            500: components["responses"]["ServerFailure"];
        };
    };
    loadCompetitionResult: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Id of the competition result of which are requested. */
                competitionId: components["schemas"]["Id.Competition"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Result for the competition found. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        entity?: components["schemas"]["CompetitionResult"];
                    };
                };
            };
            /** @description Bad input parameter, e.g. competitionId is not an integer number, or competition does not belong to allowed date range. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description required competition does not exist */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            429: components["responses"]["RateLimitAchieved"];
            500: components["responses"]["ServerFailure"];
        };
    };
    storeCompetitionResult: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Id of the competition result of which are to be stored. */
                competitionId: components["schemas"]["Id.Competition"];
            };
            cookie?: never;
        };
        /** @description Competition result. */
        requestBody: {
            content: {
                "application/json": {
                    entity?: components["schemas"]["CompetitionResult"];
                };
            };
        };
        responses: {
            /** @description Result for the competition have been replaced. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Result for the competition have been created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description According to error, the response can be empty or not:
             *
             *     * Empty (none) response can be returned, when parameter is bad (e.g. competitionId is not an integer number, or so).
             *     * Content response is returned, with error description, when a try to upload result is done later than allowed, or when result does not meet validation criteria.
             *      */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        errors?: components["schemas"]["ResultUploadError"];
                    };
                };
            };
            /** @description Required competition does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            500: components["responses"]["ServerFailure"];
        };
    };
    deleteCompetitionResult: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Id of the competition result of which are to be deleted. */
                competitionId: components["schemas"]["Id.Competition"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Result for the competition have been deleted. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Required competition does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            500: components["responses"]["ServerFailure"];
        };
    };
    loadCompetitionDances: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Id of the competition dances of which are requested. */
                competitionId: components["schemas"]["Id.Competition"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Result for the competition found. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The array can be empty. */
                        collection: components["schemas"]["Dance"][];
                        paging?: components["schemas"]["Paging"] & unknown;
                    };
                };
            };
            /** @description Bad input parameter, e.g. competitionId is not an integer number, or competition does not belong to allowed date range. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description required competition does not exist */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            429: components["responses"]["RateLimitAchieved"];
            500: components["responses"]["ServerFailure"];
        };
    };
    listEvents: {
        parameters: {
            query?: {
                /** @description Date from, event end date is considered. If not present, 10 days ago are taken. */
                from?: components["schemas"]["Date"];
                /** @description Date to, event start date is considered. If not present, 20 days ahead are taken. */
                to?: components["schemas"]["Date"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of competition events within selected range is returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The array can be empty. */
                        collection: components["schemas"]["EventInfo"][];
                        paging?: components["schemas"]["Paging"] & unknown;
                    };
                };
            };
            /** @description Bad input parameter, e.g. date is improperly formatted, or allowed range limits are exceeded.
             *      */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            429: components["responses"]["RateLimitAchieved"];
            500: components["responses"]["ServerFailure"];
        };
    };
    loadEvent: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Id of particular event to be loaded. */
                eventId: components["schemas"]["Id.Event"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Event found, its data is returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        entity?: components["schemas"]["Event"];
                    };
                };
            };
            /** @description Bad input parameter, e.g. eventId is not an integer number, or event does not belong to allowed date range. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Required event does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            429: components["responses"]["RateLimitAchieved"];
            500: components["responses"]["ServerFailure"];
        };
    };
    listEventCompetitors: {
        parameters: {
            query?: {
                page?: components["schemas"]["Page"];
                /** @description If pageSize is empty server decides about number of items to return. */
                pageSize?: components["schemas"]["PageSize"];
            };
            header?: never;
            path: {
                /** @description Id of the event startlist of which is requested. */
                eventId: components["schemas"]["Id.Event"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Event found, list of all its competitors is returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The array can be empty. */
                        collection: components["schemas"]["EventStartListCompetitor"][];
                        paging?: components["schemas"]["Paging"];
                    };
                };
            };
            /** @description Bad input parameter, e.g. eventId is not an integer number, or event does not belong to allowed date range. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Required event does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            429: components["responses"]["RateLimitAchieved"];
            500: components["responses"]["ServerFailure"];
        };
    };
    listOfficials: {
        parameters: {
            query?: {
                page?: components["schemas"]["Page"];
                /** @description If pageSize is empty server decides about number of items to return. */
                pageSize?: components["schemas"]["PageSize"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of officials. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The array can be empty. */
                        collection: components["schemas"]["Official"][];
                        paging?: components["schemas"]["Paging"];
                    };
                };
            };
            429: components["responses"]["RateLimitAchieved"];
            500: components["responses"]["ServerFailure"];
        };
    };
    loadOfficial: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Id of the official requested. */
                officialId: components["schemas"]["Id.Official"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Official found. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        entity?: components["schemas"]["Official"];
                    };
                };
            };
            /** @description Bad input parameter, e.g. officialId is not an integer number. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Required official does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            429: components["responses"]["RateLimitAchieved"];
            500: components["responses"]["ServerFailure"];
        };
    };
}
type WithRequired<T, K extends keyof T> = T & {
    [P in K]-?: T[P];
};
